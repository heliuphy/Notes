# CppPrimer-Chap2
## 类型转换
### 自动类型转换

 1. 当给某种类型的对象强行赋予另一种类型的值时，比如：
 
 ```
 bool b = 42; //赋值后，cout << b ; 会得到 b = 1  （会自动将42转换为b的类型）
 int i = b; // i的值为1
 i = 3.14 // i的值为3
 double pi = i; //pi的值为3.0
 ```
 
 
 2. 当在程序的某处使用了一种算数类型的值而其实所需的是另一种类型的值时，比如：如果我们使用了一个非布尔值作为条件，那么它会自动被转换为布尔值，这和把非布尔值赋给布尔变量的操作完全一样。
 ```
 int i = 42;
 if (i) //if条件的值将为true
    i = 0;
 ```
 
## 变量
C++中，每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式、该空间能存储的值的范围，以及变量能参与的运算。

对程序员来说，
“变量(variable)”和“对象(object)”一般可互换使用。

### 变量定义
基本形式：
```
类型说明符 变量名列表
```
即，首先是类型说明符，随后紧跟一个或多个变量名组成的列表，其中变量名以逗号分隔。（更通用的描述，见“复合类型”部分）
### 变量声明和定义的关系
如果想声明一个变量而**非**定义它，就在变量名前添加关键字`extern`而不要显式地初始化变量：
```
extern int i; //声明i而非定义i
int j; //声明并定义j
```

## 复合类型
是指**基于其他类型**而定义的类型。C++有几种复合类型，例如：引用和指针。

**声明语句**更通用的描述是：一条声明语句由一个**基本数据类型**和紧随其后的一个**声明符列表**组成。每个声明符命名了一个变量并指定该变量为与基本数据类型**有关**的某种类型。（一般来讲，**声明符**就是**变量名**。）
### 引用
引用为对象起了另外一个名字，通过将**声明符**写成`&d`的形式来定义引用类型。
```
int ival = 1024;
int &refVal = ival; //refVal指向ival（是ival的另一个名字）
int &refVal2; //报错：引用必须被初始化
```
定义引用时，程序把引用和它的初值**绑定在一起**，而**不是拷贝**。一旦初始化，就**永远**绑定。（所以必须初始化）

**注：**引用即**别名**，引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。定义了引用后，**对其进行的所有操作**都是在**与之绑定的对象上**进行的。
```
refVal = 2; //把2赋值给refVal指向的对象，即ival
int ii = refVal; //与ii = ival 执行结果一样
```
为引用赋值，实际上是把值赋给了**与引用绑定的对象**。获取引用的值，实际上是获取了**与引用绑定的对象**的值。

**注：**因为引用本身不是一个对象，所以**不能定义引用的引用**。

### 指针
指针与引用的不同：

 1. 指针本身就是一个对象
 2. 指针无需在定义时赋值

**注意：**某些符号有多重含义，像`&`和`*`这样的符号，既能用作表达式里的运算符，也能作为声明的一部分出现，符号的上下文决定了符号的意义：


```
int i = 42;
int &r = i; //&紧随类型名出线，因此是声明的一部分，r是一个引用
int *p; //*紧随类型名出线，因此是声明的一部分，p是一个指针
p = &i; //&出线在表达式中，是一个取地址符
*p = i; //*出现在表达式中，是一个解引用符
int &r2 = *p; //&是声明的一部分，*是一个解引用符
```

以前我就经常混淆，是不是`int *p = 2`就能把2赋值给`p`所指的对象，因为`*p`是解引用，这里就误解了此处`*`的含义。此处的`*`只是声明符的一部分，而不是解引用。
#### 指向指针的引用
引用本身不是一个对象，但指针是对象，所以存在指针的引用。
```
int i = 42;
int *p;
int *&r = p; //r是对指针p的引用，要理解r的类型到底是什么，最简单的办法是从右向左阅读r的定义。离变量名最近的符号，（此处是&）对变量的类型有最直接的影响，因此r是一个引用。声明符的其余部分（此处是*）用以确定r引用的类型是什么，此例中的符号*说明r引用的是一个指针。

r = &i;
*r = 0;
```

## const限定符
const是用来干嘛的？是为了警惕防止**程序**不小心改变了这个值，而不是防止人（确切来说，使用变量其实是为了方便人来改变这个值）。
```
const int bufSize = 512;
```
这样就把`bufSize`定义成了一个常量，任何试图为`bufSize`赋值的行为都将引发错误：
```
bufSize = 512; //错误！！！
```
也就是说`const`变量只能人为改变，且**只能在定义的时候改变**，所以`const`变量**必须初始化**。

 - 默认状态下，`const`对象仅在文件内有效。当然，也可以用一些办法跨文件共享。
 编译器在编译的时候把遇到`const`的地方都换成初始值，所以必须在该文件中找到此`const`变量。如果在不同文件中都定义了：
```
const int a;
```
那么不同文件采用不同文件的`a`值。

那如果想不同文件间`const`文件共享怎么办呢?那就需要对于`const`变量不管是声明还是定义都添加`extern`关键字。
```
extern const int bufSize = fcn(); //定义时要加extern
extern const int bufSize; //在另一个文件中声明时也要加extern
```
### const的引用
**引用的类型必须与其所引用的对象类型一致，但有两个例外。**
第一种情况是在**初始化常量引用时**，允许用**任意表达式**作为初始值，只要该表达式的结果能转换成引用的类型即可。（尤其，允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式）

```
const int ci = 1024;
const int &r1 = ci; //正确
r1 = 42; //错误
int &r2 = ci; //错误
```
由上可看出，对常量的引用不能被用作修改它所绑定的对象。

当一个常量引用被绑定到另外一种类型上时到底发生了什么呢？
比如：
```
double dval = 3.14;
const int &ri = dval;
```
编译器把上述代码变为了：
```
const int temp = dval;
const int &ri = temp; //让ri绑定了这个临时量
```
若`ri`不是常量时，改变`ri`实际上是改变了`temp`，而非`dval`，这是没价值的，所以C++不允许这样。

**注意：**对`const`的引用可能是一个并非`const`的对象。如：
```
int i = 42;
const int &r2 = i;
```
这样**只是不允许**通过`r2`来改变`i`的值，而直接改变i的值还是可以的。

### 指针和const
```
const double pi = 3.14;
double *ptr = &pi;
const double *cptr = &pi;
```
**综上：**要想存放常量对象的地址，只能使用指向常量的指针。

指针的类型必须与其所指向的类型一致，**但有两个意外**，一个是允许令一个指向常量的指针指向一个那个量非常量对象，只是不允许通过该指针来改变它的值。

**这样想：**这两种引用和指针的特殊情况，可以认为是指针或引用**“自以为是”地认为自己指向了常量**，所以要求自己不能去改变他们的值。

### const指针
指针是一个对象，所以可以把指针定义为常量，这只是说这个指针变量里存的地址不可改变，而非这个指针指向的变量的值不可改变。

**理解下面的代码很有帮助：**
```
int errNumb = 0;
int *const curErr = &errNumb; //1
const double pi = 3.14;
const double *const pip = &pi; //2
```

和前面一样，要想弄懂语句1和语句2的含义，就要**从右往左看**。
先看语句1：离`curErr`最近的符号是`const`，说明它是一个常量；对象`curErr`的类型由**声明符**的其余部分决定。*也就是说`curErr`是一个常量指针；最后，该声明语句的**基本数据类型部分**确定了常量指针指向的是一个`int`对象。

再看语句2：可看出`pip`是一个常量指针，它所指向的对象是一个双精度浮点型**常量**。

### 顶层const和底层const

### constexpr和常量表达式

## 处理类型
### 类型别名
```
typedef double wages; //传统方法，关键字typedef
using SI = Sales_item; //新方法，别名声明，关键字using
```

### auto类型说明符
```
auto item = val1 + val2; //由val1和val2相加的结果推断出item的类型
```

### decltype类型指示符
与`auto`不同，`decltype`可以只用表达式的类型来定义变量的类型，而不必用表达式的值来初始化变量的值。
```
decltye(f()) sum = x; //  decltye(f())这个整体，这里就是类型说明符（像int一样）。那编译器为sum指定什么类型呢？就是假如f被调用的话将会返回的那个类型。
```

## 头文件

 1. 类通常被定义在头文件中，而且类所在头文件的名字应与类的名字一样。
 2. 当头文件用到其他头文件的时候，也要包含进来。
 3. 为了防止多次包含，有必要在书写头文件时做适当处理，使其遇到多次包含的情况也能安全和正常地工作。
 4. 确保头文件多次包含仍能安全工作的常用技术是**预处理器**，在编译之前执行，可以部分地改变我们的程序，就像**预处理功能**`#include`，当预处理器看到`#include`标记时就会用指定的头文件的内容来代替`#include`。
 5. 此处用到的**预处理功能**是**头文件保护符**，`#define`指令把一个名字设定为预处理变量； `#ifdef`变量已定义时为真； `#ifndef`变量未定义时为真； 一旦检查结果为真，则执行后续操作直至遇到`#endif`指令为止。
 
```
#ifndef SALES_DATA_H
#define SALES_DATA_H
#include <string>
struct Sales_data {
...
};
#endif
```

**注：**通常基于头文件中类的名字来构建保护符的名字，并一般将预处理变量的名字大写。